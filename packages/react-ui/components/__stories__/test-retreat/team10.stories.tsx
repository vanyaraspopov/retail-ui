import { CSFStory } from 'creevey';
import React from 'react';

import { Autocomplete } from '../../Autocomplete'; // 4

export default {
  title: 'TR 10',
};

const BASIC_AUTOCOMPLETE_ITEMS = ['one', 'two', 'three'];


export const BasicAutocomplete: CSFStory<JSX.Element> = () => {
  const [value, updateValue] = React.useState('');
  return (
    <div style={{ padding: '4px 200px 200px 4px' }}>
      <Autocomplete source={['one', 'two', 'three']} value={value} onValueChange={updateValue} />
    </div>
  );
};

/**
 *  Autocomplete. Ð’Ñ‹Ð±Ð¾Ñ€ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð¿Ð¾ Enter
 *
 *  0. Ð˜ÑÑ‚Ð¾Ñ€Ð¸Ñ BasicAutocomplete
 *  1. ÐÐ°Ð¹Ñ‚Ð¸ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ Ð½Ð° ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ðµ
 *  2. Ð¤Ð¾ÐºÑƒÑ Ð½Ð° Ð¿Ð¾Ð»Ðµ Ð²Ð²Ð¾Ð´Ð°
 *  3. ðŸ“¸ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ "Ð² Ñ„Ð¾ÐºÑƒÑÐµ"
 *  4. Ð’Ð²ÐµÑÑ‚Ð¸ ÑÐ¸Ð¼Ð²Ð¾Ð» "Ð¾"
 *  5. ðŸ“¸ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ â€œÐ²Ð²ÐµÐ´ÐµÐ½Ð½Ñ‹Ð¹ ÑÐ¸Ð¼Ð²Ð¾Ð»â€
 *  6. ÐÐ°Ð¶Ð°Ñ‚ÑŒ ÐºÐ»Ð°Ð²Ð¸ÑˆÑƒ ARROW_DOWN
 *  7. ðŸ“¸ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ â€œÐ¿Ð¾Ð´ÑÐ²ÐµÑ‡ÐµÐ½ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚â€
 *  8. ÐÐ°Ð¶Ð°Ñ‚ÑŒ ÐºÐ»Ð°Ð²Ð¸ÑˆÑƒ ENTER
 *  9. ðŸ“¸ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ â€œÐ²Ñ‹Ð±Ñ€Ð°Ð½ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚â€
 *
 *  Profit!
 */

BasicAutocomplete.story = {
  parameters: {
    creevey: {
      tests: {
        async itemNotFound() {
          const element = await this.browser.findElement({ css: '#test-element' });
          const input = await this.browser.findElement({ css: '[data-comp-name~=Autocomplete]' });

          await this.browser
            .actions({ bridge: true })
            .click(input)
            .sendKeys('a', this.keys.ARROW_DOWN)
            .perform();

          const absent = await element.takeScreenshot();

          await this.expect({ absent }).to.matchImages();
        },

        async itemNotFoundAfterFillExtraChar() {
          const element = await this.browser.findElement({ css: '#test-element' });
          const input = await this.browser.findElement({ css: '[data-comp-name~=Autocomplete]' });

          await this.browser
            .actions({ bridge: true })
            .click(input)
            .sendKeys('o', this.keys.ARROW_DOWN)
            .perform();

          const highlighted = await element.takeScreenshot();

          await this.browser
            .actions({ bridge: true })
            .sendKeys('!', this.keys.ARROW_DOWN)
            .perform();

          const absent = await element.takeScreenshot();

          await this.expect({ highlighted, absent }).to.matchImages();
        },

        async itemtFoundAfterFixMisprint() {
          const element = await this.browser.findElement({ css: '#test-element' });
          const input = await this.browser.findElement({ css: '[data-comp-name~=Autocomplete]' });

          await this.browser
            .actions({ bridge: true })
            .click(input)
            .sendKeys('ob', this.keys.ARROW_DOWN)
            .perform();

          const absent = await element.takeScreenshot();

          await this.browser
            .actions({ bridge: true })
            .sendKeys(this.keys.BACK_SPACE, this.keys.ARROW_DOWN, this.keys.ENTER)
            .perform();

          const selected = await element.takeScreenshot();

          await this.expect({ absent, selected }).to.matchImages();
        },

        async firstItemSelectedAfterLast() {
          const element = await this.browser.findElement({ css: '#test-element' });
          const input = await this.browser.findElement({ css: '[data-comp-name~=Autocomplete]' });
          const typedText = 'o';

          await this.browser
            .actions({ bridge: true })
            .click(input)
            .sendKeys(typedText)
            .perform();

          const filteredItemsLength = BASIC_AUTOCOMPLETE_ITEMS.filter(item =>
            item
              .trim()
              .toLowerCase()
              .includes(typedText),
          ).length;
          const arrowDownKeysArray: string[] = Array(filteredItemsLength + 1).fill(this.keys.ARROW_DOWN);

          await this.browser
            .actions({ bridge: true })
            .sendKeys(...arrowDownKeysArray, this.keys.ENTER)
            .perform();

          const selected = await element.takeScreenshot();

          await this.expect({ selected }).to.matchImages();
        },
      },
    },
  },
};
